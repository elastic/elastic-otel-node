// Copyright 2021, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// OpAMP: Open Agent Management Protocol (https://github.com/open-telemetry/opamp-spec)

// @generated by protoc-gen-es v2.7.0 with parameter "target=js+dts,js_import_style=legacy_commonjs"
// @generated from file opamp.proto (package opamp.proto, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { KeyValue } from "./anyvalue_pb";

/**
 * Describes the file opamp.proto.
 */
export declare const file_opamp: GenFile;

/**
 * @generated from message opamp.proto.AgentToServer
 */
export declare type AgentToServer = Message<"opamp.proto.AgentToServer"> & {
  /**
   * Globally unique identifier of the running instance of the Agent. SHOULD remain
   * unchanged for the lifetime of the Agent process.
   * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
   *
   * @generated from field: bytes instance_uid = 1;
   */
  instanceUid: Uint8Array;

  /**
   * The sequence number is incremented by 1 for every AgentToServer sent
   * by the Agent. This allows the Server to detect that it missed a message when
   * it notices that the sequence_num is not exactly by 1 greater than the previously
   * received one.
   *
   * @generated from field: uint64 sequence_num = 2;
   */
  sequenceNum: bigint;

  /**
   * Data that describes the Agent, its type, where it runs, etc.
   * May be omitted if nothing changed since last AgentToServer message.
   *
   * @generated from field: opamp.proto.AgentDescription agent_description = 3;
   */
  agentDescription?: AgentDescription;

  /**
   * Bitmask of flags defined by AgentCapabilities enum.
   * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
   * the Agent. This allows extending the protocol and the AgentCapabilities enum
   * in the future such that old Agents automatically report that they don't
   * support the new capability.
   * This field MUST be always set.
   *
   * @generated from field: uint64 capabilities = 4;
   */
  capabilities: bigint;

  /**
   * The current health of the Agent and sub-components. The top-level ComponentHealth represents
   * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
   * message.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ComponentHealth health = 5;
   */
  health?: ComponentHealth;

  /**
   * The current effective configuration of the Agent. The effective configuration is
   * the one that is currently used by the Agent. The effective configuration may be
   * different from the remote configuration received from the Server earlier, e.g.
   * because the Agent uses a local configuration instead (or in addition).
   *
   * This field SHOULD be unset if the effective config is unchanged since the last
   * AgentToServer message.
   *
   * @generated from field: opamp.proto.EffectiveConfig effective_config = 6;
   */
  effectiveConfig?: EffectiveConfig;

  /**
   * The status of the remote config that was previously received from the Server.
   * This field SHOULD be unset if the remote config status is unchanged since the
   * last AgentToServer message.
   *
   * @generated from field: opamp.proto.RemoteConfigStatus remote_config_status = 7;
   */
  remoteConfigStatus?: RemoteConfigStatus;

  /**
   * The list of the Agent packages, including package statuses. This field SHOULD be
   * unset if this information is unchanged since the last AgentToServer message for
   * this Agent was sent in the stream.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.PackageStatuses package_statuses = 8;
   */
  packageStatuses?: PackageStatuses;

  /**
   * AgentDisconnect MUST be set in the last AgentToServer message sent from the
   * Agent to the Server.
   *
   * @generated from field: opamp.proto.AgentDisconnect agent_disconnect = 9;
   */
  agentDisconnect?: AgentDisconnect;

  /**
   * Bit flags as defined by AgentToServerFlags bit masks.
   *
   * @generated from field: uint64 flags = 10;
   */
  flags: bigint;

  /**
   * A request to create connection settings. This field is set for flows where
   * the Agent initiates the creation of connection settings.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;
   */
  connectionSettingsRequest?: ConnectionSettingsRequest;

  /**
   * A message indicating custom capabilities supported by the Agent.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomCapabilities custom_capabilities = 12;
   */
  customCapabilities?: CustomCapabilities;

  /**
   * A custom message sent from an Agent to the Server.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomMessage custom_message = 13;
   */
  customMessage?: CustomMessage;

  /**
   * A message indicating the components that are available for configuration on the agent.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.AvailableComponents available_components = 14;
   */
  availableComponents?: AvailableComponents;
};

/**
 * Describes the message opamp.proto.AgentToServer.
 * Use `create(AgentToServerSchema)` to create a new message.
 */
export declare const AgentToServerSchema: GenMessage<AgentToServer>;

/**
 * AgentDisconnect is the last message sent from the Agent to the Server. The Server
 * SHOULD forget the association of the Agent instance with the message stream.
 *
 * If the message stream is closed in the transport layer then the Server SHOULD
 * forget association of all Agent instances that were previously established for
 * this message stream using AgentConnect message, even if the corresponding
 * AgentDisconnect message were not explicitly received from the Agent.
 *
 * @generated from message opamp.proto.AgentDisconnect
 */
export declare type AgentDisconnect = Message<"opamp.proto.AgentDisconnect"> & {
};

/**
 * Describes the message opamp.proto.AgentDisconnect.
 * Use `create(AgentDisconnectSchema)` to create a new message.
 */
export declare const AgentDisconnectSchema: GenMessage<AgentDisconnect>;

/**
 * ConnectionSettingsRequest is a request from the Agent to the Server to create
 * and respond with an offer of connection settings for the Agent.
 * Status: [Development]
 *
 * @generated from message opamp.proto.ConnectionSettingsRequest
 */
export declare type ConnectionSettingsRequest = Message<"opamp.proto.ConnectionSettingsRequest"> & {
  /**
   * Request for OpAMP connection settings. If this field is unset
   * then the ConnectionSettingsRequest message is empty and is not actionable
   * for the Server.
   *
   * @generated from field: opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;
   */
  opamp?: OpAMPConnectionSettingsRequest;
};

/**
 * Describes the message opamp.proto.ConnectionSettingsRequest.
 * Use `create(ConnectionSettingsRequestSchema)` to create a new message.
 */
export declare const ConnectionSettingsRequestSchema: GenMessage<ConnectionSettingsRequest>;

/**
 * OpAMPConnectionSettingsRequest is a request for the Server to produce
 * a OpAMPConnectionSettings in its response.
 * Status: [Development]
 *
 * @generated from message opamp.proto.OpAMPConnectionSettingsRequest
 */
export declare type OpAMPConnectionSettingsRequest = Message<"opamp.proto.OpAMPConnectionSettingsRequest"> & {
  /**
   * A request to create a client certificate. This is used to initiate a
   * Client Signing Request (CSR) flow.
   * Required.
   *
   * @generated from field: opamp.proto.CertificateRequest certificate_request = 1;
   */
  certificateRequest?: CertificateRequest;
};

/**
 * Describes the message opamp.proto.OpAMPConnectionSettingsRequest.
 * Use `create(OpAMPConnectionSettingsRequestSchema)` to create a new message.
 */
export declare const OpAMPConnectionSettingsRequestSchema: GenMessage<OpAMPConnectionSettingsRequest>;

/**
 * Status: [Development]
 *
 * @generated from message opamp.proto.CertificateRequest
 */
export declare type CertificateRequest = Message<"opamp.proto.CertificateRequest"> & {
  /**
   * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
   * The Server SHOULD validate the request and SHOULD respond with a
   * OpAMPConnectionSettings where the certificate.cert contains the issued
   * certificate.
   *
   * @generated from field: bytes csr = 1;
   */
  csr: Uint8Array;
};

/**
 * Describes the message opamp.proto.CertificateRequest.
 * Use `create(CertificateRequestSchema)` to create a new message.
 */
export declare const CertificateRequestSchema: GenMessage<CertificateRequest>;

/**
 * AvailableComponents contains metadata relating to the components included
 * within the agent.
 * status: [Development]
 *
 * @generated from message opamp.proto.AvailableComponents
 */
export declare type AvailableComponents = Message<"opamp.proto.AvailableComponents"> & {
  /**
   * A map of a unique component ID to details about the component.
   * This may be omitted from the message if the server has not
   * explicitly requested it be sent by setting the ReportAvailableComponents
   * flag in the previous ServerToAgent message.
   *
   * @generated from field: map<string, opamp.proto.ComponentDetails> components = 1;
   */
  components: { [key: string]: ComponentDetails };

  /**
   * Agent-calculated hash of the components.
   * This hash should be included in every AvailableComponents message.
   *
   * @generated from field: bytes hash = 2;
   */
  hash: Uint8Array;
};

/**
 * Describes the message opamp.proto.AvailableComponents.
 * Use `create(AvailableComponentsSchema)` to create a new message.
 */
export declare const AvailableComponentsSchema: GenMessage<AvailableComponents>;

/**
 * @generated from message opamp.proto.ComponentDetails
 */
export declare type ComponentDetails = Message<"opamp.proto.ComponentDetails"> & {
  /**
   * Extra key/value pairs that may be used to describe the component.
   * The key/value pairs are according to semantic conventions, see:
   * https://opentelemetry.io/docs/specs/semconv/
   *
   * For example, you may use the "code" semantic conventions to
   * report the location of the code for a specific component:
   * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
   *
   * Or you may use the "vcs" semantic conventions to report the
   * repository the component may be a part of:
   * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
   *
   * @generated from field: repeated opamp.proto.KeyValue metadata = 1;
   */
  metadata: KeyValue[];

  /**
   * A map of component ID to sub components details. It can nest as deeply as needed to
   * describe the underlying system.
   *
   * @generated from field: map<string, opamp.proto.ComponentDetails> sub_component_map = 2;
   */
  subComponentMap: { [key: string]: ComponentDetails };
};

/**
 * Describes the message opamp.proto.ComponentDetails.
 * Use `create(ComponentDetailsSchema)` to create a new message.
 */
export declare const ComponentDetailsSchema: GenMessage<ComponentDetails>;

/**
 * @generated from message opamp.proto.ServerToAgent
 */
export declare type ServerToAgent = Message<"opamp.proto.ServerToAgent"> & {
  /**
   * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
   * Used for multiplexing messages from/to multiple agents using one message stream.
   *
   * @generated from field: bytes instance_uid = 1;
   */
  instanceUid: Uint8Array;

  /**
   * error_response is set if the Server wants to indicate that something went wrong
   * during processing of an AgentToServer message. If error_response is set then
   * all other fields below must be unset and vice versa, if any of the fields below is
   * set then error_response must be unset.
   *
   * @generated from field: opamp.proto.ServerErrorResponse error_response = 2;
   */
  errorResponse?: ServerErrorResponse;

  /**
   * remote_config field is set when the Server has a remote config offer for the Agent.
   *
   * @generated from field: opamp.proto.AgentRemoteConfig remote_config = 3;
   */
  remoteConfig?: AgentRemoteConfig;

  /**
   * This field is set when the Server wants the Agent to change one or more
   * of its client connection settings (destination, headers, certificate, etc).
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ConnectionSettingsOffers connection_settings = 4;
   */
  connectionSettings?: ConnectionSettingsOffers;

  /**
   * This field is set when the Server has packages to offer to the Agent.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.PackagesAvailable packages_available = 5;
   */
  packagesAvailable?: PackagesAvailable;

  /**
   * Bit flags as defined by ServerToAgentFlags bit masks.
   *
   * @generated from field: uint64 flags = 6;
   */
  flags: bigint;

  /**
   * Bitmask of flags defined by ServerCapabilities enum.
   * All bits that are not defined in ServerCapabilities enum MUST be set to 0
   * by the Server. This allows extending the protocol and the ServerCapabilities
   * enum in the future such that old Servers automatically report that they
   * don't support the new capability.
   * This field MUST be set in the first ServerToAgent sent by the Server and MAY
   * be omitted in subsequent ServerToAgent messages by setting it to
   * UnspecifiedServerCapability value.
   *
   * @generated from field: uint64 capabilities = 7;
   */
  capabilities: bigint;

  /**
   * Properties related to identification of the Agent, which can be overridden
   * by the Server if needed.
   *
   * @generated from field: opamp.proto.AgentIdentification agent_identification = 8;
   */
  agentIdentification?: AgentIdentification;

  /**
   * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
   * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
   * will be performed.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ServerToAgentCommand command = 9;
   */
  command?: ServerToAgentCommand;

  /**
   * A message indicating custom capabilities supported by the Server.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomCapabilities custom_capabilities = 10;
   */
  customCapabilities?: CustomCapabilities;

  /**
   * A custom message sent from the Server to an Agent.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomMessage custom_message = 11;
   */
  customMessage?: CustomMessage;
};

/**
 * Describes the message opamp.proto.ServerToAgent.
 * Use `create(ServerToAgentSchema)` to create a new message.
 */
export declare const ServerToAgentSchema: GenMessage<ServerToAgent>;

/**
 * The OpAMPConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for OpAMP
 * connection.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.OpAMPConnectionSettings
 */
export declare type OpAMPConnectionSettings = Message<"opamp.proto.OpAMPConnectionSettings"> & {
  /**
   * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
   * example: "wss://example.com:4318/v1/opamp"
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;

  /**
   * The Agent MUST periodically send an AgentToServer message if the
   * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
   * field MUST be set.
   *
   * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
   *
   * A heartbeat is used to keep the connection active and inform the server that the Agent
   * is still alive and active.
   *
   * If this field has no value or is set to 0, the Agent should not send any heartbeats.
   * Status: [Development]
   *
   * @generated from field: uint64 heartbeat_interval_seconds = 4;
   */
  heartbeatIntervalSeconds: bigint;
};

/**
 * Describes the message opamp.proto.OpAMPConnectionSettings.
 * Use `create(OpAMPConnectionSettingsSchema)` to create a new message.
 */
export declare const OpAMPConnectionSettingsSchema: GenMessage<OpAMPConnectionSettings>;

/**
 * The TelemetryConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for a network
 * connection to report own telemetry.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.TelemetryConnectionSettings
 */
export declare type TelemetryConnectionSettings = Message<"opamp.proto.TelemetryConnectionSettings"> & {
  /**
   * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
   * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
   * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;
};

/**
 * Describes the message opamp.proto.TelemetryConnectionSettings.
 * Use `create(TelemetryConnectionSettingsSchema)` to create a new message.
 */
export declare const TelemetryConnectionSettingsSchema: GenMessage<TelemetryConnectionSettings>;

/**
 * The OtherConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for a network
 * connection. It is not required that all fields in this message are specified.
 * The Server may specify only some of the fields, in which case it means that
 * the Server offers the Agent to change only those fields, while keeping the
 * rest of the fields unchanged.
 *
 * For example the Server may send a ConnectionSettings message with only the
 * certificate field set, while all other fields are unset. This means that
 * the Server wants the Agent to use a new certificate and continue sending to
 * the destination it is currently sending using the current header and other
 * settings.
 *
 * For fields which reference other messages the field is considered unset
 * when the reference is unset.
 *
 * For primitive field (string) we rely on the "flags" to describe that the
 * field is not set (this is done to overcome the limitation of old protoc
 * compilers don't generate methods that allow to check for the presence of
 * the field.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.OtherConnectionSettings
 */
export declare type OtherConnectionSettings = Message<"opamp.proto.OtherConnectionSettings"> & {
  /**
   * A URL, host:port or some other destination specifier.
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;

  /**
   * Other connection settings. These are Agent-specific and are up to the Agent
   * interpret.
   *
   * @generated from field: map<string, string> other_settings = 4;
   */
  otherSettings: { [key: string]: string };
};

/**
 * Describes the message opamp.proto.OtherConnectionSettings.
 * Use `create(OtherConnectionSettingsSchema)` to create a new message.
 */
export declare const OtherConnectionSettingsSchema: GenMessage<OtherConnectionSettings>;

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.Headers
 */
export declare type Headers = Message<"opamp.proto.Headers"> & {
  /**
   * @generated from field: repeated opamp.proto.Header headers = 1;
   */
  headers: Header[];
};

/**
 * Describes the message opamp.proto.Headers.
 * Use `create(HeadersSchema)` to create a new message.
 */
export declare const HeadersSchema: GenMessage<Headers>;

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.Header
 */
export declare type Header = Message<"opamp.proto.Header"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string value = 2;
   */
  value: string;
};

/**
 * Describes the message opamp.proto.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export declare const HeaderSchema: GenMessage<Header>;

/**
 * Status: [Beta]
 *
 * The (cert,private_key) pair should be issued and signed by a Certificate
 * Authority (CA) that the destination Server recognizes.
 *
 * It is highly recommended that the private key of the CA certificate is NOT
 * stored on the destination Server otherwise compromising the Server will allow
 * a malicious actor to issue valid Server certificates which will be automatically
 * trusted by all agents and will allow the actor to trivially MITM Agent-to-Server
 * traffic of all servers that use this CA certificate for their Server-side
 * certificates.
 *
 * Alternatively the certificate may be self-signed, assuming the Server can
 * verify the certificate.
 *
 * @generated from message opamp.proto.TLSCertificate
 */
export declare type TLSCertificate = Message<"opamp.proto.TLSCertificate"> & {
  /**
   * PEM-encoded certificate. Required.
   *
   * @generated from field: bytes cert = 1;
   */
  cert: Uint8Array;

  /**
   * PEM-encoded private key of the certificate. Required.
   *
   * @generated from field: bytes private_key = 2;
   */
  privateKey: Uint8Array;

  /**
   * PEM-encoded certificate of the signing CA.
   * Optional. MUST be specified if the certificate is CA-signed.
   * Can be stored by TLS-terminating intermediary proxies in order to verify
   * the connecting client's certificate in the future.
   * It is not recommended that the Agent accepts this CA as an authority for
   * any purposes.
   *
   * @generated from field: bytes ca_cert = 3;
   */
  caCert: Uint8Array;
};

/**
 * Describes the message opamp.proto.TLSCertificate.
 * Use `create(TLSCertificateSchema)` to create a new message.
 */
export declare const TLSCertificateSchema: GenMessage<TLSCertificate>;

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ConnectionSettingsOffers
 */
export declare type ConnectionSettingsOffers = Message<"opamp.proto.ConnectionSettingsOffers"> & {
  /**
   * Hash of all settings, including settings that may be omitted from this message
   * because they are unchanged.
   *
   * @generated from field: bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * Settings to connect to the OpAMP Server.
   * If this field is not set then the Agent should assume that the settings are
   * unchanged and should continue using existing settings.
   * The Agent MUST verify the offered connection settings by actually connecting
   * before accepting the setting to ensure it does not loose access to the OpAMP
   * Server due to invalid settings.
   *
   * @generated from field: opamp.proto.OpAMPConnectionSettings opamp = 2;
   */
  opamp?: OpAMPConnectionSettings;

  /**
   * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
   * If this field is not set then the Agent should assume that the settings
   * are unchanged.
   *
   * Once accepted the Agent should periodically send to the specified destination
   * its own metrics, i.e. metrics of the Agent process and any custom metrics that
   * describe the Agent state.
   *
   * All attributes specified in the identifying_attributes field in AgentDescription
   * message SHOULD be also specified in the Resource of the reported OTLP metrics.
   *
   * Attributes specified in the non_identifying_attributes field in
   * AgentDescription message may be also specified in the Resource of the reported
   * OTLP metrics, in which case they SHOULD have exactly the same values.
   *
   * Process metrics MUST follow the conventions for processes:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_metrics = 3;
   */
  ownMetrics?: TelemetryConnectionSettings;

  /**
   * Similar to own_metrics, but for traces.
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_traces = 4;
   */
  ownTraces?: TelemetryConnectionSettings;

  /**
   * Similar to own_metrics, but for logs.
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_logs = 5;
   */
  ownLogs?: TelemetryConnectionSettings;

  /**
   * Another set of connection settings, with a string name associated with each.
   * How the Agent uses these is Agent-specific. Typically the name represents
   * the name of the destination to connect to (as it is known to the Agent).
   * If this field is not set then the Agent should assume that the other_connections
   * settings are unchanged.
   *
   * @generated from field: map<string, opamp.proto.OtherConnectionSettings> other_connections = 6;
   */
  otherConnections: { [key: string]: OtherConnectionSettings };
};

/**
 * Describes the message opamp.proto.ConnectionSettingsOffers.
 * Use `create(ConnectionSettingsOffersSchema)` to create a new message.
 */
export declare const ConnectionSettingsOffersSchema: GenMessage<ConnectionSettingsOffers>;

/**
 * List of packages that the Server offers to the Agent.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackagesAvailable
 */
export declare type PackagesAvailable = Message<"opamp.proto.PackagesAvailable"> & {
  /**
   * Map of packages. Keys are package names, values are the packages available for download.
   *
   * @generated from field: map<string, opamp.proto.PackageAvailable> packages = 1;
   */
  packages: { [key: string]: PackageAvailable };

  /**
   * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
   * value in subsequent PackageStatuses messages. This in turn allows the management
   * Server to identify that a different set of packages is available for the Agent
   * and specify the available packages in the next ServerToAgent message.
   *
   * This field MUST be always set if the management Server supports packages
   * of agents.
   *
   * The hash is calculated as an aggregate of all packages names and content.
   *
   * @generated from field: bytes all_packages_hash = 2;
   */
  allPackagesHash: Uint8Array;
};

/**
 * Describes the message opamp.proto.PackagesAvailable.
 * Use `create(PackagesAvailableSchema)` to create a new message.
 */
export declare const PackagesAvailableSchema: GenMessage<PackagesAvailable>;

/**
 * Each Agent is composed of one or more packages. A package has a name and
 * content stored in a file. The content of the files, functionality
 * provided by the packages, how they are stored and used by the Agent side is Agent
 * type-specific and is outside the concerns of the OpAMP protocol.
 *
 * If the Agent does not have an installed package with the specified name then
 * it SHOULD download it from the specified URL and install it.
 *
 * If the Agent already has an installed package with the specified name
 * but with a different hash then the Agent SHOULD download and
 * install the package again, since it is a different version of the same package.
 *
 * If the Agent has an installed package with the specified name and the same
 * hash then the Agent does not need to do anything, it already
 * has the right version of the package.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageAvailable
 */
export declare type PackageAvailable = Message<"opamp.proto.PackageAvailable"> & {
  /**
   * @generated from field: opamp.proto.PackageType type = 1;
   */
  type: PackageType;

  /**
   * The package version that is available on the Server side. The Agent may for
   * example use this information to avoid downloading a package that was previously
   * already downloaded and failed to install.
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * The downloadable file of the package.
   *
   * @generated from field: opamp.proto.DownloadableFile file = 3;
   */
  file?: DownloadableFile;

  /**
   * The hash of the package. SHOULD be calculated based on all other fields of the
   * PackageAvailable message and content of the file of the package. The hash is
   * used by the Agent to determine if the package it has is different from the
   * package the Server is offering.
   *
   * @generated from field: bytes hash = 4;
   */
  hash: Uint8Array;
};

/**
 * Describes the message opamp.proto.PackageAvailable.
 * Use `create(PackageAvailableSchema)` to create a new message.
 */
export declare const PackageAvailableSchema: GenMessage<PackageAvailable>;

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.DownloadableFile
 */
export declare type DownloadableFile = Message<"opamp.proto.DownloadableFile"> & {
  /**
   * The URL from which the file can be downloaded using HTTP GET request.
   * The Server at the specified URL SHOULD support range requests
   * to allow for resuming downloads.
   *
   * @generated from field: string download_url = 1;
   */
  downloadUrl: string;

  /**
   * The hash of the file content. Can be used by the Agent to verify that the file
   * was downloaded correctly.
   *
   * @generated from field: bytes content_hash = 2;
   */
  contentHash: Uint8Array;

  /**
   * Optional signature of the file content. Can be used by the Agent to verify the
   * authenticity of the downloaded file, for example can be the
   * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
   * The exact signing and verification method is Agent specific. See
   * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
   * for recommendations.
   *
   * @generated from field: bytes signature = 3;
   */
  signature: Uint8Array;

  /**
   * Optional headers to use when downloading a file. Typically used to set
   * access tokens or other authorization headers. For HTTP-based protocols
   * the Agent should set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   * Status: [Development]
   *
   * @generated from field: opamp.proto.Headers headers = 4;
   */
  headers?: Headers;
};

/**
 * Describes the message opamp.proto.DownloadableFile.
 * Use `create(DownloadableFileSchema)` to create a new message.
 */
export declare const DownloadableFileSchema: GenMessage<DownloadableFile>;

/**
 * @generated from message opamp.proto.ServerErrorResponse
 */
export declare type ServerErrorResponse = Message<"opamp.proto.ServerErrorResponse"> & {
  /**
   * @generated from field: opamp.proto.ServerErrorResponseType type = 1;
   */
  type: ServerErrorResponseType;

  /**
   * Error message in the string form, typically human readable.
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from oneof opamp.proto.ServerErrorResponse.Details
   */
  Details: {
    /**
     * Additional information about retrying if type==UNAVAILABLE.
     *
     * @generated from field: opamp.proto.RetryInfo retry_info = 3;
     */
    value: RetryInfo;
    case: "retryInfo";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message opamp.proto.ServerErrorResponse.
 * Use `create(ServerErrorResponseSchema)` to create a new message.
 */
export declare const ServerErrorResponseSchema: GenMessage<ServerErrorResponse>;

/**
 * @generated from message opamp.proto.RetryInfo
 */
export declare type RetryInfo = Message<"opamp.proto.RetryInfo"> & {
  /**
   * @generated from field: uint64 retry_after_nanoseconds = 1;
   */
  retryAfterNanoseconds: bigint;
};

/**
 * Describes the message opamp.proto.RetryInfo.
 * Use `create(RetryInfoSchema)` to create a new message.
 */
export declare const RetryInfoSchema: GenMessage<RetryInfo>;

/**
 * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
 * perform a command.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ServerToAgentCommand
 */
export declare type ServerToAgentCommand = Message<"opamp.proto.ServerToAgentCommand"> & {
  /**
   * @generated from field: opamp.proto.CommandType type = 1;
   */
  type: CommandType;
};

/**
 * Describes the message opamp.proto.ServerToAgentCommand.
 * Use `create(ServerToAgentCommandSchema)` to create a new message.
 */
export declare const ServerToAgentCommandSchema: GenMessage<ServerToAgentCommand>;

/**
 * @generated from message opamp.proto.AgentDescription
 */
export declare type AgentDescription = Message<"opamp.proto.AgentDescription"> & {
  /**
   * Attributes that identify the Agent.
   * Keys/values are according to OpenTelemetry semantic conventions, see:
   * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
   *
   * For standalone running Agents (such as OpenTelemetry Collector) the following
   * attributes SHOULD be specified:
   * - service.name should be set to a reverse FQDN that uniquely identifies the
   *   Agent type, e.g. "io.opentelemetry.collector"
   * - service.namespace if it is used in the environment where the Agent runs.
   * - service.version should be set to version number of the Agent build.
   * - service.instance.id should be set. It may be set equal to the Agent's
   *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
   *   that uniquely identifies the Agent in combination with other attributes.
   * - any other attributes that are necessary for uniquely identifying the Agent's
   *   own telemetry.
   *
   * The Agent SHOULD also include these attributes in the Resource of its own
   * telemetry. The combination of identifying attributes SHOULD be sufficient to
   * uniquely identify the Agent's own telemetry in the destination system to which
   * the Agent sends its own telemetry.
   *
   * @generated from field: repeated opamp.proto.KeyValue identifying_attributes = 1;
   */
  identifyingAttributes: KeyValue[];

  /**
   * Attributes that do not necessarily identify the Agent but help describe
   * where it runs.
   * The following attributes SHOULD be included:
   * - os.type, os.version - to describe where the Agent runs.
   * - host.* to describe the host the Agent runs on.
   * - cloud.* to describe the cloud where the host is located.
   * - any other relevant Resource attributes that describe this Agent and the
   *   environment it runs in.
   * - any user-defined attributes that the end user would like to associate
   *   with this Agent.
   *
   * @generated from field: repeated opamp.proto.KeyValue non_identifying_attributes = 2;
   */
  nonIdentifyingAttributes: KeyValue[];
};

/**
 * Describes the message opamp.proto.AgentDescription.
 * Use `create(AgentDescriptionSchema)` to create a new message.
 */
export declare const AgentDescriptionSchema: GenMessage<AgentDescription>;

/**
 * The health of the Agent and sub-components
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ComponentHealth
 */
export declare type ComponentHealth = Message<"opamp.proto.ComponentHealth"> & {
  /**
   * Set to true if the component is up and healthy.
   *
   * @generated from field: bool healthy = 1;
   */
  healthy: boolean;

  /**
   * Timestamp since the component is up, i.e. when the component was started.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   * If the component is not running MUST be set to 0.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano: bigint;

  /**
   * Human-readable error message if the component is in erroneous state. SHOULD be set
   * when healthy==false.
   *
   * @generated from field: string last_error = 3;
   */
  lastError: string;

  /**
   * Component status represented as a string. The status values are defined by agent-specific
   * semantics and not at the protocol level.
   *
   * @generated from field: string status = 4;
   */
  status: string;

  /**
   * The time when the component status was observed. Value is UNIX Epoch time in
   * nanoseconds since 00:00:00 UTC on 1 January 1970.
   *
   * @generated from field: fixed64 status_time_unix_nano = 5;
   */
  statusTimeUnixNano: bigint;

  /**
   * A map to store more granular, sub-component health. It can nest as deeply as needed to
   * describe the underlying system.
   *
   * @generated from field: map<string, opamp.proto.ComponentHealth> component_health_map = 6;
   */
  componentHealthMap: { [key: string]: ComponentHealth };
};

/**
 * Describes the message opamp.proto.ComponentHealth.
 * Use `create(ComponentHealthSchema)` to create a new message.
 */
export declare const ComponentHealthSchema: GenMessage<ComponentHealth>;

/**
 * @generated from message opamp.proto.EffectiveConfig
 */
export declare type EffectiveConfig = Message<"opamp.proto.EffectiveConfig"> & {
  /**
   * The effective config of the Agent.
   *
   * @generated from field: opamp.proto.AgentConfigMap config_map = 1;
   */
  configMap?: AgentConfigMap;
};

/**
 * Describes the message opamp.proto.EffectiveConfig.
 * Use `create(EffectiveConfigSchema)` to create a new message.
 */
export declare const EffectiveConfigSchema: GenMessage<EffectiveConfig>;

/**
 * @generated from message opamp.proto.RemoteConfigStatus
 */
export declare type RemoteConfigStatus = Message<"opamp.proto.RemoteConfigStatus"> & {
  /**
   * The hash of the remote config that was last received by this Agent in the
   * AgentRemoteConfig.config_hash field.
   * The Server SHOULD compare this hash with the config hash
   * it has for the Agent and if the hashes are different the Server MUST include
   * the remote_config field in the response in the ServerToAgent message.
   *
   * @generated from field: bytes last_remote_config_hash = 1;
   */
  lastRemoteConfigHash: Uint8Array;

  /**
   * @generated from field: opamp.proto.RemoteConfigStatuses status = 2;
   */
  status: RemoteConfigStatuses;

  /**
   * Optional error message if status==FAILED.
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;
};

/**
 * Describes the message opamp.proto.RemoteConfigStatus.
 * Use `create(RemoteConfigStatusSchema)` to create a new message.
 */
export declare const RemoteConfigStatusSchema: GenMessage<RemoteConfigStatus>;

/**
 * The PackageStatuses message describes the status of all packages that the Agent
 * has or was offered.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageStatuses
 */
export declare type PackageStatuses = Message<"opamp.proto.PackageStatuses"> & {
  /**
   * A map of PackageStatus messages, where the keys are package names.
   * The key MUST match the name field of PackageStatus message.
   *
   * @generated from field: map<string, opamp.proto.PackageStatus> packages = 1;
   */
  packages: { [key: string]: PackageStatus };

  /**
   * The aggregate hash of all packages that this Agent previously received from the
   * Server via PackagesAvailable message.
   *
   * The Server SHOULD compare this hash to the aggregate hash of all packages that
   * it has for this Agent and if the hashes are different the Server SHOULD send
   * an PackagesAvailable message to the Agent.
   *
   * @generated from field: bytes server_provided_all_packages_hash = 2;
   */
  serverProvidedAllPackagesHash: Uint8Array;

  /**
   * This field is set if the Agent encountered an error when processing the
   * PackagesAvailable message and that error is not related to any particular single
   * package.
   * The field must be unset is there were no processing errors.
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;
};

/**
 * Describes the message opamp.proto.PackageStatuses.
 * Use `create(PackageStatusesSchema)` to create a new message.
 */
export declare const PackageStatusesSchema: GenMessage<PackageStatuses>;

/**
 * The status of a single package.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageStatus
 */
export declare type PackageStatus = Message<"opamp.proto.PackageStatus"> & {
  /**
   * Package name. MUST be always set and MUST match the key in the packages field
   * of PackageStatuses message.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The version of the package that the Agent has.
   * MUST be set if the Agent has this package.
   * MUST be empty if the Agent does not have this package. This may be the case
   * for example if the package was offered by the Server but failed to install
   * and the Agent did not have this package previously.
   *
   * @generated from field: string agent_has_version = 2;
   */
  agentHasVersion: string;

  /**
   * The hash of the package that the Agent has.
   * MUST be set if the Agent has this package.
   * MUST be empty if the Agent does not have this package. This may be the case for
   * example if the package was offered by the Server but failed to install and the
   * Agent did not have this package previously.
   *
   * @generated from field: bytes agent_has_hash = 3;
   */
  agentHasHash: Uint8Array;

  /**
   * The version of the package that the Server offered to the Agent.
   * MUST be set if the installation of the package is initiated by an earlier offer
   * from the Server to install this package.
   *
   * MUST be empty if the Agent has this package but it was installed locally and
   * was not offered by the Server.
   *
   * Note that it is possible for both agent_has_version and server_offered_version
   * fields to be set and to have different values. This is for example possible if
   * the Agent already has a version of the package successfully installed, the Server
   * offers a different version, but the Agent fails to install that version.
   *
   * @generated from field: string server_offered_version = 4;
   */
  serverOfferedVersion: string;

  /**
   * The hash of the package that the Server offered to the Agent.
   * MUST be set if the installation of the package is initiated by an earlier
   * offer from the Server to install this package.
   *
   * MUST be empty if the Agent has this package but it was installed locally and
   * was not offered by the Server.
   *
   * Note that it is possible for both agent_has_hash and server_offered_hash
   * fields to be set and to have different values. This is for example possible if
   * the Agent already has a version of the package successfully installed, the
   * Server offers a different version, but the Agent fails to install that version.
   *
   * @generated from field: bytes server_offered_hash = 5;
   */
  serverOfferedHash: Uint8Array;

  /**
   * @generated from field: opamp.proto.PackageStatusEnum status = 6;
   */
  status: PackageStatusEnum;

  /**
   * Error message if the status is erroneous.
   *
   * @generated from field: string error_message = 7;
   */
  errorMessage: string;

  /**
   * Optional details that may be of interest to a user.
   * Should only be set if status is Downloading.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.PackageDownloadDetails download_details = 8;
   */
  downloadDetails?: PackageDownloadDetails;
};

/**
 * Describes the message opamp.proto.PackageStatus.
 * Use `create(PackageStatusSchema)` to create a new message.
 */
export declare const PackageStatusSchema: GenMessage<PackageStatus>;

/**
 * Additional details that an agent can use to describe an in-progress package download.
 * Status: [Development]
 *
 * @generated from message opamp.proto.PackageDownloadDetails
 */
export declare type PackageDownloadDetails = Message<"opamp.proto.PackageDownloadDetails"> & {
  /**
   * The package download progress as a percentage.
   *
   * @generated from field: double download_percent = 1;
   */
  downloadPercent: number;

  /**
   * The current package download rate in bytes per second.
   *
   * @generated from field: double download_bytes_per_second = 2;
   */
  downloadBytesPerSecond: number;
};

/**
 * Describes the message opamp.proto.PackageDownloadDetails.
 * Use `create(PackageDownloadDetailsSchema)` to create a new message.
 */
export declare const PackageDownloadDetailsSchema: GenMessage<PackageDownloadDetails>;

/**
 * Properties related to identification of the Agent, which can be overridden
 * by the Server if needed
 *
 * @generated from message opamp.proto.AgentIdentification
 */
export declare type AgentIdentification = Message<"opamp.proto.AgentIdentification"> & {
  /**
   * When new_instance_uid is set, Agent MUST update instance_uid
   * to the value provided and use it for all further communication.
   * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
   *
   * @generated from field: bytes new_instance_uid = 1;
   */
  newInstanceUid: Uint8Array;
};

/**
 * Describes the message opamp.proto.AgentIdentification.
 * Use `create(AgentIdentificationSchema)` to create a new message.
 */
export declare const AgentIdentificationSchema: GenMessage<AgentIdentification>;

/**
 * @generated from message opamp.proto.AgentRemoteConfig
 */
export declare type AgentRemoteConfig = Message<"opamp.proto.AgentRemoteConfig"> & {
  /**
   * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
   * set if the config for this Agent has not changed since it was last requested (i.e.
   * AgentConfigRequest.last_remote_config_hash field is equal to
   * AgentConfigResponse.config_hash field).
   *
   * @generated from field: opamp.proto.AgentConfigMap config = 1;
   */
  config?: AgentConfigMap;

  /**
   * Hash of "config". The Agent SHOULD include this value in subsequent
   * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
   * allows the management Server to identify that a new config is available for the Agent.
   *
   * This field MUST be always set if the management Server supports remote configuration
   * of agents.
   *
   * Management Server must choose a hashing function that guarantees lack of hash
   * collisions in practice.
   *
   * @generated from field: bytes config_hash = 2;
   */
  configHash: Uint8Array;
};

/**
 * Describes the message opamp.proto.AgentRemoteConfig.
 * Use `create(AgentRemoteConfigSchema)` to create a new message.
 */
export declare const AgentRemoteConfigSchema: GenMessage<AgentRemoteConfig>;

/**
 * @generated from message opamp.proto.AgentConfigMap
 */
export declare type AgentConfigMap = Message<"opamp.proto.AgentConfigMap"> & {
  /**
   * Map of configs. Keys are config file names or config section names.
   * The configuration is assumed to be a collection of one or more named config files
   * or sections.
   * For agents that use a single config file or section the map SHOULD contain a single
   * entry and the key may be an empty string.
   *
   * @generated from field: map<string, opamp.proto.AgentConfigFile> config_map = 1;
   */
  configMap: { [key: string]: AgentConfigFile };
};

/**
 * Describes the message opamp.proto.AgentConfigMap.
 * Use `create(AgentConfigMapSchema)` to create a new message.
 */
export declare const AgentConfigMapSchema: GenMessage<AgentConfigMap>;

/**
 * @generated from message opamp.proto.AgentConfigFile
 */
export declare type AgentConfigFile = Message<"opamp.proto.AgentConfigFile"> & {
  /**
   * Config file or section body. The content, format and encoding depends on the Agent
   * type. The content_type field may optionally describe the MIME type of the body.
   *
   * @generated from field: bytes body = 1;
   */
  body: Uint8Array;

  /**
   * Optional MIME Content-Type that describes what's in the body field, for
   * example "text/yaml".
   *
   * @generated from field: string content_type = 2;
   */
  contentType: string;
};

/**
 * Describes the message opamp.proto.AgentConfigFile.
 * Use `create(AgentConfigFileSchema)` to create a new message.
 */
export declare const AgentConfigFileSchema: GenMessage<AgentConfigFile>;

/**
 * @generated from message opamp.proto.CustomCapabilities
 */
export declare type CustomCapabilities = Message<"opamp.proto.CustomCapabilities"> & {
  /**
   * A list of custom capabilities that are supported. Each capability is a reverse FQDN
   * with optional version information that uniquely identifies the custom capability
   * and should match a capability specified in a supported CustomMessage.
   * Status: [Development]
   *
   * @generated from field: repeated string capabilities = 1;
   */
  capabilities: string[];
};

/**
 * Describes the message opamp.proto.CustomCapabilities.
 * Use `create(CustomCapabilitiesSchema)` to create a new message.
 */
export declare const CustomCapabilitiesSchema: GenMessage<CustomCapabilities>;

/**
 * @generated from message opamp.proto.CustomMessage
 */
export declare type CustomMessage = Message<"opamp.proto.CustomMessage"> & {
  /**
   * A reverse FQDN that uniquely identifies the capability and matches one of the
   * capabilities in the CustomCapabilities message.
   * Status: [Development]
   *
   * @generated from field: string capability = 1;
   */
  capability: string;

  /**
   * Type of message within the capability. The capability defines the types of custom
   * messages that are used to implement the capability. The type must only be unique
   * within the capability.
   * Status: [Development]
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Binary data of the message. The capability must specify the format of the contents
   * of the data for each custom message type it defines.
   * Status: [Development]
   *
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;
};

/**
 * Describes the message opamp.proto.CustomMessage.
 * Use `create(CustomMessageSchema)` to create a new message.
 */
export declare const CustomMessageSchema: GenMessage<CustomMessage>;

/**
 * @generated from enum opamp.proto.AgentToServerFlags
 */
export enum AgentToServerFlags {
  /**
   * @generated from enum value: AgentToServerFlags_Unspecified = 0;
   */
  AgentToServerFlags_Unspecified = 0,

  /**
   * The Agent requests Server go generate a new instance_uid, which will
   * be sent back in ServerToAgent message
   *
   * @generated from enum value: AgentToServerFlags_RequestInstanceUid = 1;
   */
  AgentToServerFlags_RequestInstanceUid = 1,
}

/**
 * Describes the enum opamp.proto.AgentToServerFlags.
 */
export declare const AgentToServerFlagsSchema: GenEnum<AgentToServerFlags>;

/**
 * @generated from enum opamp.proto.ServerToAgentFlags
 */
export enum ServerToAgentFlags {
  /**
   * @generated from enum value: ServerToAgentFlags_Unspecified = 0;
   */
  ServerToAgentFlags_Unspecified = 0,

  /**
   * ReportFullState flag can be used by the Server if the Agent did not include the
   * particular bit of information in the last status report (which is an allowed
   * optimization) but the Server detects that it does not have it (e.g. was
   * restarted and lost state). The detection happens using
   * AgentToServer.sequence_num values.
   * The Server asks the Agent to report full status.
   *
   * @generated from enum value: ServerToAgentFlags_ReportFullState = 1;
   */
  ServerToAgentFlags_ReportFullState = 1,

  /**
   * ReportAvailableComponents flag can be used by the server if the Agent did
   * not include the full AvailableComponents message, but only the hash.
   * If this flag is specified, the agent will populate available_components.components
   * with a full description of the agent's components.
   * Status: [Development]
   *
   * @generated from enum value: ServerToAgentFlags_ReportAvailableComponents = 2;
   */
  ServerToAgentFlags_ReportAvailableComponents = 2,
}

/**
 * Describes the enum opamp.proto.ServerToAgentFlags.
 */
export declare const ServerToAgentFlagsSchema: GenEnum<ServerToAgentFlags>;

/**
 * @generated from enum opamp.proto.ServerCapabilities
 */
export enum ServerCapabilities {
  /**
   * The capabilities field is unspecified.
   *
   * @generated from enum value: ServerCapabilities_Unspecified = 0;
   */
  ServerCapabilities_Unspecified = 0,

  /**
   * The Server can accept status reports. This bit MUST be set, since all Server
   * MUST be able to accept status reports.
   *
   * @generated from enum value: ServerCapabilities_AcceptsStatus = 1;
   */
  ServerCapabilities_AcceptsStatus = 1,

  /**
   * The Server can offer remote configuration to the Agent.
   *
   * @generated from enum value: ServerCapabilities_OffersRemoteConfig = 2;
   */
  ServerCapabilities_OffersRemoteConfig = 2,

  /**
   * The Server can accept EffectiveConfig in AgentToServer.
   *
   * @generated from enum value: ServerCapabilities_AcceptsEffectiveConfig = 4;
   */
  ServerCapabilities_AcceptsEffectiveConfig = 4,

  /**
   * The Server can offer Packages.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_OffersPackages = 8;
   */
  ServerCapabilities_OffersPackages = 8,

  /**
   * The Server can accept Packages status.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_AcceptsPackagesStatus = 16;
   */
  ServerCapabilities_AcceptsPackagesStatus = 16,

  /**
   * The Server can offer connection settings.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_OffersConnectionSettings = 32;
   */
  ServerCapabilities_OffersConnectionSettings = 32,

  /**
   * The Server can accept ConnectionSettingsRequest and respond with an offer.
   * Status: [Development]
   *
   * @generated from enum value: ServerCapabilities_AcceptsConnectionSettingsRequest = 64;
   */
  ServerCapabilities_AcceptsConnectionSettingsRequest = 64,
}

/**
 * Describes the enum opamp.proto.ServerCapabilities.
 */
export declare const ServerCapabilitiesSchema: GenEnum<ServerCapabilities>;

/**
 * The type of the package, either an addon or a top-level package.
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.PackageType
 */
export enum PackageType {
  /**
   * @generated from enum value: PackageType_TopLevel = 0;
   */
  PackageType_TopLevel = 0,

  /**
   * @generated from enum value: PackageType_Addon = 1;
   */
  PackageType_Addon = 1,
}

/**
 * Describes the enum opamp.proto.PackageType.
 */
export declare const PackageTypeSchema: GenEnum<PackageType>;

/**
 * @generated from enum opamp.proto.ServerErrorResponseType
 */
export enum ServerErrorResponseType {
  /**
   * Unknown error. Something went wrong, but it is not known what exactly.
   * The Agent SHOULD NOT retry the message.
   * The error_message field may contain a description of the problem.
   *
   * @generated from enum value: ServerErrorResponseType_Unknown = 0;
   */
  ServerErrorResponseType_Unknown = 0,

  /**
   * The AgentToServer message was malformed. The Agent SHOULD NOT retry
   * the message.
   *
   * @generated from enum value: ServerErrorResponseType_BadRequest = 1;
   */
  ServerErrorResponseType_BadRequest = 1,

  /**
   * The Server is overloaded and unable to process the request. The Agent
   * should retry the message later. retry_info field may be optionally
   * set with additional information about retrying.
   *
   * @generated from enum value: ServerErrorResponseType_Unavailable = 2;
   */
  ServerErrorResponseType_Unavailable = 2,
}

/**
 * Describes the enum opamp.proto.ServerErrorResponseType.
 */
export declare const ServerErrorResponseTypeSchema: GenEnum<ServerErrorResponseType>;

/**
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.CommandType
 */
export enum CommandType {
  /**
   * The Agent should restart. This request will be ignored if the Agent does not
   * support restart.
   *
   * @generated from enum value: CommandType_Restart = 0;
   */
  CommandType_Restart = 0,
}

/**
 * Describes the enum opamp.proto.CommandType.
 */
export declare const CommandTypeSchema: GenEnum<CommandType>;

/**
 * @generated from enum opamp.proto.AgentCapabilities
 */
export enum AgentCapabilities {
  /**
   * The capabilities field is unspecified.
   *
   * @generated from enum value: AgentCapabilities_Unspecified = 0;
   */
  AgentCapabilities_Unspecified = 0,

  /**
   * The Agent can report status. This bit MUST be set, since all Agents MUST
   * report status.
   *
   * @generated from enum value: AgentCapabilities_ReportsStatus = 1;
   */
  AgentCapabilities_ReportsStatus = 1,

  /**
   * The Agent can accept remote configuration from the Server.
   *
   * @generated from enum value: AgentCapabilities_AcceptsRemoteConfig = 2;
   */
  AgentCapabilities_AcceptsRemoteConfig = 2,

  /**
   * The Agent will report EffectiveConfig in AgentToServer.
   *
   * @generated from enum value: AgentCapabilities_ReportsEffectiveConfig = 4;
   */
  AgentCapabilities_ReportsEffectiveConfig = 4,

  /**
   * The Agent can accept package offers.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsPackages = 8;
   */
  AgentCapabilities_AcceptsPackages = 8,

  /**
   * The Agent can report package status.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsPackageStatuses = 16;
   */
  AgentCapabilities_ReportsPackageStatuses = 16,

  /**
   * The Agent can report own trace to the destination specified by
   * the Server via ConnectionSettingsOffers.own_traces field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnTraces = 32;
   */
  AgentCapabilities_ReportsOwnTraces = 32,

  /**
   * The Agent can report own metrics to the destination specified by
   * the Server via ConnectionSettingsOffers.own_metrics field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnMetrics = 64;
   */
  AgentCapabilities_ReportsOwnMetrics = 64,

  /**
   * The Agent can report own logs to the destination specified by
   * the Server via ConnectionSettingsOffers.own_logs field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnLogs = 128;
   */
  AgentCapabilities_ReportsOwnLogs = 128,

  /**
   * The can accept connections settings for OpAMP via
   * ConnectionSettingsOffers.opamp field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;
   */
  AgentCapabilities_AcceptsOpAMPConnectionSettings = 256,

  /**
   * The can accept connections settings for other destinations via
   * ConnectionSettingsOffers.other_connections field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsOtherConnectionSettings = 512;
   */
  AgentCapabilities_AcceptsOtherConnectionSettings = 512,

  /**
   * The Agent can accept restart requests.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsRestartCommand = 1024;
   */
  AgentCapabilities_AcceptsRestartCommand = 1024,

  /**
   * The Agent will report Health via AgentToServer.health field.
   *
   * @generated from enum value: AgentCapabilities_ReportsHealth = 2048;
   */
  AgentCapabilities_ReportsHealth = 2048,

  /**
   * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
   *
   * @generated from enum value: AgentCapabilities_ReportsRemoteConfig = 4096;
   */
  AgentCapabilities_ReportsRemoteConfig = 4096,

  /**
   * The Agent can report heartbeats.
   * This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
   * If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
   * Agent should use its own configured interval, which by default will be 30s. The Server may not
   * know the configured interval and should not make assumptions about it.
   * Status: [Development]
   *
   * @generated from enum value: AgentCapabilities_ReportsHeartbeat = 8192;
   */
  AgentCapabilities_ReportsHeartbeat = 8192,

  /**
   * The agent will report AvailableComponents via the AgentToServer.available_components field.
   * Status: [Development]
   *
   * Add new capabilities here, continuing with the least significant unused bit.
   *
   * @generated from enum value: AgentCapabilities_ReportsAvailableComponents = 16384;
   */
  AgentCapabilities_ReportsAvailableComponents = 16384,
}

/**
 * Describes the enum opamp.proto.AgentCapabilities.
 */
export declare const AgentCapabilitiesSchema: GenEnum<AgentCapabilities>;

/**
 * @generated from enum opamp.proto.RemoteConfigStatuses
 */
export enum RemoteConfigStatuses {
  /**
   * The value of status field is not set.
   *
   * @generated from enum value: RemoteConfigStatuses_UNSET = 0;
   */
  RemoteConfigStatuses_UNSET = 0,

  /**
   * Remote config was successfully applied by the Agent.
   *
   * @generated from enum value: RemoteConfigStatuses_APPLIED = 1;
   */
  RemoteConfigStatuses_APPLIED = 1,

  /**
   * Agent is currently applying the remote config that it received earlier.
   *
   * @generated from enum value: RemoteConfigStatuses_APPLYING = 2;
   */
  RemoteConfigStatuses_APPLYING = 2,

  /**
   * Agent tried to apply the config received earlier, but it failed.
   * See error_message for more details.
   *
   * @generated from enum value: RemoteConfigStatuses_FAILED = 3;
   */
  RemoteConfigStatuses_FAILED = 3,
}

/**
 * Describes the enum opamp.proto.RemoteConfigStatuses.
 */
export declare const RemoteConfigStatusesSchema: GenEnum<RemoteConfigStatuses>;

/**
 * The status of this package.
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.PackageStatusEnum
 */
export enum PackageStatusEnum {
  /**
   * Package is successfully installed by the Agent.
   * The error_message field MUST NOT be set.
   *
   * @generated from enum value: PackageStatusEnum_Installed = 0;
   */
  PackageStatusEnum_Installed = 0,

  /**
   * Installation of this package has not yet started.
   *
   * @generated from enum value: PackageStatusEnum_InstallPending = 1;
   */
  PackageStatusEnum_InstallPending = 1,

  /**
   * Agent is currently installing the package.
   * server_offered_hash field MUST be set to indicate the version that the
   * Agent is installing. The error_message field MUST NOT be set.
   *
   * @generated from enum value: PackageStatusEnum_Installing = 2;
   */
  PackageStatusEnum_Installing = 2,

  /**
   * Agent tried to install the package but installation failed.
   * server_offered_hash field MUST be set to indicate the version that the Agent
   * tried to install. The error_message may also contain more details about
   * the failure.
   *
   * @generated from enum value: PackageStatusEnum_InstallFailed = 3;
   */
  PackageStatusEnum_InstallFailed = 3,

  /**
   * Agent is currently downloading the package.
   * server_offered_hash field MUST be set to indicate the version that the
   * Agent is installing. The error_message field MUST NOT be set.
   * Status: [Development]
   *
   * @generated from enum value: PackageStatusEnum_Downloading = 4;
   */
  PackageStatusEnum_Downloading = 4,
}

/**
 * Describes the enum opamp.proto.PackageStatusEnum.
 */
export declare const PackageStatusEnumSchema: GenEnum<PackageStatusEnum>;

