<!doctype html>
<html>
    <head>
        <!-- https://bulma.io/ -->
        <link rel="stylesheet" href="./bulma.min.css">
        <!-- https://d3js.org/ -->
        <script src="d3.v7.min.js"></script>
        
        <link rel="stylesheet" href="./style.css">
        <title>Mock OLTP Server UI</title>
    </head>
    <body>
        <nav class="level">
            <p class="level-item has-text-centered">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" class="" role="img" aria-hidden="true">
                    <path fill="#F04E98" d="M10 32H7.238C3.793 32 1 28.865 1 24.998V15h9v17Z"></path>
                    <path d="M10 32h9V8h-9z"></path>
                    <path fill="#07C" d="M31 32h-9V0l1.973.024C27.866.072 31 3.731 31 8.228V32Z"></path>
                </svg>
            </p>
        </nav>

        <h1 class="title">Trace Details</h1>
        <h1 class="subtitle"></h1>
        <div id="chart" class="box"></div>
    </body>


    <!-- helper scripts -->
    <script>
        // formats the data for plotting
        function buildTree(spanMap, node) {
            const childSpans = spanMap[node.id];
            
            if (childSpans) {
                node.children = childSpans.map((s) => ({
                    id: s.spanId,
                    name: s.name,
                    // This is the duration
                    value: Number(BigInt(s.endTimeUnixNano) - BigInt(s.startTimeUnixNano)),
                }));
                node.children.forEach((c) => buildTree(spanMap, c));
            }

            return node;
        }

        function draw(data) {
            // Specify the chartâ€™s dimensions.
            const width = 928;
            const height = 2400;
            const format = d3.format(",d");

            // Create a color scale (a color for each child of the root node and their descendants).
            const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1))

            // Create a partition layout.
            const partition = d3.partition()
                .size([height, width])
                .padding(1);

            // Apply the partition layout.
            const root = partition(d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.height - a.height || b.value - a.value));

            // Create the SVG container.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif");

            // Add a cell for each node of the hierarchy.
            const cell = svg
                .selectAll()
                .data(root.descendants())
                .join("g")
                .attr("transform", d => `translate(${d.y0},${d.x0})`);

            cell.append("title")
                .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${format(d.value)}`);

            // Color the cell with respect to which child of root it belongs to. 
            cell.append("rect")
                .attr("width", d => d.y1 - d.y0)
                .attr("height", d => d.x1 - d.x0)
                .attr("fill-opacity", 0.6)
                .attr("fill", d => {
                    if (!d.depth) return "#ccc";
                    while (d.depth > 1) d = d.parent;
                    return color(d.data.name);
                });

            // Add labels and a title.
            const text = cell.filter(d => (d.x1 - d.x0) > 16).append("text")
                .attr("x", 4)
                .attr("y", 13);

            text.append("tspan")
                .text(d => d.data.name);

            text.append("tspan")
                .attr("fill-opacity", 0.7)
                .text(d => ` ${format(d.value)}`);

            return svg.node();
        }
    </script>

    <!-- main line -->
    <script>
        const searchParams = new URLSearchParams(location.search);
        const traceId = searchParams.get('traceId')

        if (traceId) {
            // Fetch and fill the table
        fetch(`/api/traces/${traceId}`)
            .then((res) => res.text())
            .then((ndjson) => {
                // TODO: we need better parsing for big num
                return ndjson.split('\n').filter(l => l).map(JSON.parse);
            })
            .then((spans) => {
                const spanMap = spans.sort((a, b) => {
                    return a.startTimeUnixNano < b.startTimeUnixNano ? -1 : 1;
                }).reduce((map, s) => {
                    const parentId = s.parentSpanId || traceId;
                    map[parentId] = map[parentId] || [];
                    map[parentId].push(s);
                    return map;
                }, {});

                const data = buildTree(spanMap, { id: traceId, name: 'trace' });
                const svg = draw(data);
                document.getElementById('chart').appendChild(svg);
            });
        }
    </script>
</html>